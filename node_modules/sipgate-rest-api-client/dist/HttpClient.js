'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _promiseCache = require('./promiseCache');

var _promiseCache2 = _interopRequireDefault(_promiseCache);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

require('es6-promise').polyfill();
require('isomorphic-fetch');

var defaultHeaders = function defaultHeaders(token) {
	var authorization = token ? 'Bearer ' + token : null;
	var headers = {
		Accept: 'application/json',
		'Content-Type': 'application/json',
		'X-Sipgate-Client': 'app.sipgate.com'
	};

	if (authorization) {
		headers.Authorization = authorization;
	}

	return headers;
};

var extractBody = function extractBody(res) {
	return res.text();
};

var parseJSON = function parseJSON(text) {
	try {
		return JSON.parse(text);
	} catch (e) {
		return text;
	}
};

var identity = function identity(result) {
	return result;
};

var HttpClient = function HttpClient() {
	var _this = this;

	var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    _ref$token = _ref.token,
	    token = _ref$token === undefined ? null : _ref$token,
	    _ref$apiUrl = _ref.apiUrl,
	    apiUrl = _ref$apiUrl === undefined ? '' : _ref$apiUrl,
	    _ref$onPromiseResolve = _ref.onPromiseResolved,
	    onPromiseResolved = _ref$onPromiseResolve === undefined ? identity : _ref$onPromiseResolve,
	    _ref$onUnauthorized = _ref.onUnauthorized,
	    onUnauthorized = _ref$onUnauthorized === undefined ? function () {} : _ref$onUnauthorized,
	    getToken = _ref.getToken;

	_classCallCheck(this, HttpClient);

	this.getUnauthenticated = function (path) {
		return _this.get(path, false);
	};

	this.handleUnauthorized = function (response) {
		if (response.status === 401) {
			_this.onUnauthorized();
		}
		return response;
	};

	this.get = function (path) {
		var authenticated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

		var url = _this.apiUrl + path;

		if (_promiseCache2.default.get(url)) {
			return _promiseCache2.default.get(url);
		}

		var promise = fetch(url, {
			method: 'get',
			headers: defaultHeaders(authenticated ? _this.getToken() : null)
		}).then(_this.handleUnauthorized).then(_this.onPromiseResolved).then(function (response) {
			_promiseCache2.default.bust(url);
			return response;
		}).then(extractBody).then(parseJSON).catch(function (reason) {
			_promiseCache2.default.bust(url);
			return Promise.reject(reason);
		});

		_promiseCache2.default.set(url, promise);

		return promise;
	};

	this.del = function (path) {
		return fetch(_this.apiUrl + path, {
			method: 'delete',
			headers: defaultHeaders(_this.getToken())
		}).then(_this.handleUnauthorized).then(_this.onPromiseResolved).then(extractBody).then(parseJSON);
	};

	this.post = function (path) {
		var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		return fetch(_this.apiUrl + path, {
			method: 'post',
			body: JSON.stringify(data),
			headers: defaultHeaders(_this.getToken())
		}).then(_this.handleUnauthorized).then(_this.onPromiseResolved).then(extractBody).then(parseJSON);
	};

	this.put = function (path) {
		var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		return fetch(_this.apiUrl + path, {
			method: 'put',
			body: JSON.stringify(data),
			headers: defaultHeaders(_this.getToken())
		}).then(_this.handleUnauthorized).then(_this.onPromiseResolved).then(extractBody).then(parseJSON);
	};

	this.token = token;
	this.apiUrl = apiUrl;
	this.onPromiseResolved = onPromiseResolved;
	this.onUnauthorized = onUnauthorized;
	this.getToken = function () {
		if (getToken instanceof Function) {
			return getToken();
		}

		return _this.token;
	};
};

exports.default = HttpClient;